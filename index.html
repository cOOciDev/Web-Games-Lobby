<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Three.js — Forest & Beach + Walkable Player</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html, body { height:100%; margin:0; overflow:hidden; background:#0e0f12; }
  #ui {
    position: fixed; inset: 0; display:flex; align-items:center; justify-content:center;
    color:#d4d8e0; font:14px/1.4 system-ui, sans-serif; pointer-events:none;
  }
  #hud {
    position: fixed; top:10px; left:10px; background:#0008; color:#9aa4b2;
    padding:8px 10px; border-radius:10px; font:12px/1 system-ui, sans-serif;
  }
  .btn {
    pointer-events:auto; background:#111a; border:1px solid #2a3340; color:#e5e7eb;
    padding:10px 14px; border-radius:10px; cursor:pointer; user-select:none;
  }
  .btn:hover { background:#1b2230; }
</style>
</head>
<body>
<div id="hud">WASD to move • Mouse to look • Shift = run • Click to start</div>
<div id="ui"><div class="btn" id="start">Click to enter</div></div>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.169.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.169.0/examples/jsm/"
  }
}
</script>


<script type="module">
 
  import * as THREE from "three";
  import { PointerLockControls } from "three/addons/controls/PointerLockControls.js";


/* ---------- Basic setup ---------- */
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0xa1c1e0, 0.0022);
scene.background = new THREE.Color(0xa1c1e0);

const camera = new THREE.PerspectiveCamera(70, 1, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));
document.body.appendChild(renderer.domElement);

/* ---------- Lighting & sky tint ---------- */
const hemi = new THREE.HemisphereLight(0xffffff, 0x224466, 0.85);
scene.add(hemi);
const sun = new THREE.DirectionalLight(0xfff1cf, 1.0);
sun.position.set(80,120,40);
sun.castShadow = false;
scene.add(sun);

/* ---------- Terrain (heightfield) ---------- */
const WORLD_SIZE = 600;            // meters-ish
const RES = 256;                   // grid resolution (keep moderate)
const SEA_LEVEL = 0;               // y=0 waterline
const BEACH_BAND = 6;              // meters around sea level treated as sand
const terrainGeo = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, RES, RES);
terrainGeo.rotateX(-Math.PI/2);

// Simple fractal-ish height function (fast, no external noise lib)
function h(x, z) {
  // scale down coords to get broader features
  const s = 1/60, s2 = 1/18, s3 = 1/7;
  const n1 = Math.sin(x*s) * Math.cos(z*s);
  const n2 = Math.sin(x*s2 + 1.7) * Math.sin(z*s2 - 2.1);
  const n3 = Math.cos(x*s3 - 0.7) * Math.sin(z*s3 + 0.3);
  // shape: push down near “coastline” along +X to create a beach/water edge
  const coast = THREE.MathUtils.smoothstep((x + WORLD_SIZE*0.15) / (WORLD_SIZE*0.35), 0, 1);
  const base = (n1*2 + n2*1.2 + n3*0.6) * 2.2 * coast; // low rolling hills
  const dunes = Math.sin((x+z)*0.12)*0.7 * (1 - coast); // small dunes near beach
  return base + dunes;
}

// write vertex heights + vertex colors (sand/grass/rock)
const pos = terrainGeo.attributes.position;
const colors = [];
for (let i=0; i<pos.count; i++) {
  const x = pos.getX(i);
  const z = pos.getZ(i);
  const y = h(x, z);
  pos.setY(i, y);

  // color by height band
  const dy = y - SEA_LEVEL;
  let col;
  if (dy < -0.5) {
    col = new THREE.Color(0x79b5ff); // just in case something dips below sea
  } else if (Math.abs(dy) < BEACH_BAND) {
    col = new THREE.Color(0xf1e3b0); // sand near sea level
  } else if (dy < 30) {
    col = new THREE.Color(0x5a7d4a); // grass/forest
  } else {
    col = new THREE.Color(0x8d8f93); // rocky
  }
  colors.push(col.r, col.g, col.b);
}
terrainGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
terrainGeo.computeVertexNormals();

const terrainMat = new THREE.MeshStandardMaterial({
  vertexColors: true,
  roughness: 1.0,
  metalness: 0.0
});
const terrain = new THREE.Mesh(terrainGeo, terrainMat);
terrain.receiveShadow = true;
scene.add(terrain);

/* ---------- Water (simple animated plane) ---------- */
const waterSize = WORLD_SIZE * 2;
const waterGeo = new THREE.PlaneGeometry(waterSize, waterSize, 128, 128);
waterGeo.rotateX(-Math.PI/2);
const waterMat = new THREE.MeshPhysicalMaterial({
  color: 0x7fc7ff,
  roughness: 0.4,
  metalness: 0.0,
  transmission: 0.0,
  transparent: true,
  opacity: 0.9
});
const water = new THREE.Mesh(waterGeo, waterMat);
water.position.y = SEA_LEVEL - 0.15;
scene.add(water);

/* ---------- Trees (instanced meshes: trunk + foliage) ---------- */
function makeTrees() {
  // simple pine: cylinder trunk + cone foliage
  const trunkGeo = new THREE.CylinderGeometry(0.15, 0.25, 2.2, 6);
  const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5a3a1a, roughness: 1 });
  const foliageGeo = new THREE.ConeGeometry(1.0, 3.0, 8);
  const foliageMat = new THREE.MeshStandardMaterial({ color: 0x376b2d, roughness: 0.9 });

  const COUNT = 900;
  const trunk = new THREE.InstancedMesh(trunkGeo, trunkMat, COUNT);
  const leaves = new THREE.InstancedMesh(foliageGeo, foliageMat, COUNT);
  trunk.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
  leaves.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

  const m = new THREE.Matrix4();
  const q = new THREE.Quaternion();
  const v3 = new THREE.Vector3();

  let created = 0, tries = 0;
  while (created < COUNT && tries < COUNT*10) {
    tries++;
    // distribute mostly on land away from water; skip deep beach
    const x = (Math.random() - 0.1) * WORLD_SIZE * 0.9; // bias away from negative x coast
    const z = (Math.random() - 0.5) * WORLD_SIZE * 0.9;
    const y = h(x, z);

    const dy = y - SEA_LEVEL;
    if (dy < BEACH_BAND + 1.5) continue;      // avoid sand
    if (dy > 45) continue;                    // avoid very high rocky
    if (Math.random() < 0.09) continue;       // small thinning

    // small random scale
    const s = 0.8 + Math.random()*0.8;
    // trunk
    q.setFromEuler(new THREE.Euler(0, Math.random()*Math.PI*2, 0));
    m.compose(v3.set(x, y+1.1*s, z), q, v3.set(1, 1, 1).multiplyScalar(s));
    trunk.setMatrixAt(created, m);
    // leaves
    q.setFromEuler(new THREE.Euler(0, Math.random()*Math.PI*2, 0));
    m.compose(v3.set(x, y+2.4*s, z), q, v3.set(1, 1, 1).multiplyScalar(s));
    leaves.setMatrixAt(created, m);

    created++;
  }

  trunk.instanceMatrix.needsUpdate = true;
  leaves.instanceMatrix.needsUpdate = true;
  scene.add(trunk, leaves);
}
makeTrees();

/* ---------- Player (WASD + mouse look) ---------- */
const controls = new PointerLockControls(camera, document.body);
const startBtn = document.getElementById('start');
const ui = document.getElementById('ui');
startBtn.addEventListener('click', () => {
  controls.lock();
});
controls.addEventListener('lock', () => { ui.style.display = 'none'; });
controls.addEventListener('unlock', () => { ui.style.display = 'flex'; });

const move = { f:false, b:false, l:false, r:false, run:false };
document.addEventListener('keydown', (e) => {
  if (e.code === 'KeyW') move.f = true;
  if (e.code === 'KeyS') move.b = true;
  if (e.code === 'KeyA') move.l = true;
  if (e.code === 'KeyD') move.r = true;
  if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') move.run = true;
});
document.addEventListener('keyup', (e) => {
  if (e.code === 'KeyW') move.f = false;
  if (e.code === 'KeyS') move.b = false;
  if (e.code === 'KeyA') move.l = false;
  if (e.code === 'KeyD') move.r = false;
  if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') move.run = false;
});

// player kinematics
const player = {
  height: 1.7,          // eye height above ground
  pos: new THREE.Vector3( -WORLD_SIZE*0.2, 10, 0 ),
  vel: new THREE.Vector3(),
};

// helper: get terrain height at arbitrary x,z by bilinear sampling of the grid
// (fast approximate; avoids raycasting every frame)
const gridW = RES+1, gridH = RES+1;
const step = WORLD_SIZE / RES;
function heightAt(x, z) {
  // transform world (x,z) to plane local grid (origin at center)
  const lx = (x + WORLD_SIZE/2) / step;
  const lz = (z + WORLD_SIZE/2) / step;
  const x0 = Math.floor(lx), z0 = Math.floor(lz);
  const x1 = x0 + 1, z1 = z0 + 1;
  if (x0 < 0 || z0 < 0 || x1 >= gridW || z1 >= gridH) return SEA_LEVEL - 3; // off the map -> below sea
  const ix = (i,j) => (j*gridW + i) * 3 + 1; // y index in position array
  const py = terrain.geometry.attributes.position.array;
  const y00 = py[ix(x0,z0)], y10 = py[ix(x1,z0)];
  const y01 = py[ix(x0,z1)], y11 = py[ix(x1,z1)];
  const tx = lx - x0, tz = lz - z0;
  // bilinear
  const ya = y00*(1-tx) + y10*tx;
  const yb = y01*(1-tx) + y11*tx;
  return ya*(1-tz) + yb*tz;
}

/* ---------- Resize ---------- */
function resize() {
  const w = window.innerWidth, h = window.innerHeight;
  renderer.setSize(w, h, false);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
}
window.addEventListener('resize', resize);
resize();

/* ---------- Animation loop ---------- */
let last = performance.now();
function animate(now) {
  const dt = Math.min((now - last)/1000, 0.05); // clamp big steps
  last = now;

  // gentle water ripple
  const wa = water.geometry.attributes.position;
  for (let i=0; i<wa.count; i++) {
    const x = water.geometry.attributes.position.getX(i);
    const z = water.geometry.attributes.position.getZ(i);
    const yy = SEA_LEVEL - 0.15 + Math.sin((x+now*0.12)*0.02)*0.06 + Math.cos((z-now*0.09)*0.02)*0.06;
    wa.setY(i, yy);
  }
  wa.needsUpdate = true;
  water.geometry.computeVertexNormals();

  // Player movement
  const speed = (move.run ? 11 : 6);     // m/s
  const dir = new THREE.Vector3();
  if (controls.isLocked) {
    // movement in camera local X/Z
    const forward = new THREE.Vector3();
    controls.getDirection(forward);  // unit forward
    forward.y = 0; forward.normalize();
    const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).negate();

    dir.set(0,0,0);
    if (move.f) dir.add(forward);
    if (move.b) dir.sub(forward);
    if (move.l) dir.sub(right);
    if (move.r) dir.add(right);
    if (dir.lengthSq() > 0) dir.normalize();

    // integrate velocity (simple, no accel)
    player.pos.addScaledVector(dir, speed * dt);

    // keep inside world bounds
    player.pos.x = THREE.MathUtils.clamp(player.pos.x, -WORLD_SIZE*0.49, WORLD_SIZE*0.49);
    player.pos.z = THREE.MathUtils.clamp(player.pos.z, -WORLD_SIZE*0.49, WORLD_SIZE*0.49);

    // snap to ground (no jumping for simplicity)
    const groundY = heightAt(player.pos.x, player.pos.z);
    player.pos.y = groundY + player.height;

    controls.getObject().position.copy(player.pos);
    camera.position.copy(player.pos);
  }

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

/* ---------- Start position & look ---------- */
controls.getObject().position.copy(player.pos);
camera.position.copy(player.pos);
camera.lookAt(player.pos.x+10, player.pos.y, player.pos.z);
</script>
</body>
</html>
